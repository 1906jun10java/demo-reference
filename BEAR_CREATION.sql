--DB CREATION SCRIPTS OFTEN BEGIN WITH 'DROP' STATEMENTS TO AVOID CLASHES WITH EXISTING TABLES
DROP TABLE BEAR;
/
DROP TABLE BEAR_TYPE;
/
DROP TABLE CAVE;
/ 
DROP TABLE BEEHIVE;
/ 
DROP TABLE BEAR_BEEHIVE;
/

--TABLE CREATION WITH PRIMARY KEYS

CREATE TABLE BEAR (
    BEAR_ID INTEGER PRIMARY KEY,
    BEAR_NAME VARCHAR2(100), --100 CHARACTERS OF SPACE, 
    -- VARCHAR2 INTERPRETS NULL AND EMPTY STRING AS SAME VALUE (VARCHAR DOES NOT)
    BIRTHDATE DATE,
    WEIGHT NUMBER(6, 2) DEFAULT 200.00,
    BEAR_TYPE_ID INTEGER NOT NULL, --APPLIED A NOT NULL CONSTRAINT, WILL BE FK
    CAVE_ID INTEGER --WILL BE A NULLABLE FK
);
/
CREATE TABLE BEAR_TYPE (
    BEAR_TYPE_ID INTEGER PRIMARY KEY,
    BEAR_TYPE_NAME VARCHAR2(100)
);
/
CREATE TABLE CAVE (
    CAVE_ID INTEGER PRIMARY KEY,
    CAVE_NAME VARCHAR2(100),
    MAX_BEARS INTEGER DEFAULT 4
);
/
CREATE TABLE BEEHIVE (
    BEEHIVE_ID INTEGER PRIMARY KEY,
    LBS_HONEY NUMBER(5,2) DEFAULT 75.00
);
/
CREATE TABLE BEAR_BEEHIVE (
    BEAR_ID INTEGER,
    BEEHIVE_ID INTEGER,
    PRIMARY KEY (BEAR_ID, BEEHIVE_ID) --COMPOSITE PRIMARY KEY
);
/

--FOREIGN KEY CONSTRAINTS

--CONSTRAINT: RULE PLACE ON THE CONTENTS OF A TABLE, 
--LIMITING WHAT MAY BE INSERTED INTO A COLUMN
--TYPES: PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK (INCLUDES NOT NULL)

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);
/
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE(CAVE_ID);
/
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEAR
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);
/
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/
--ADD SOME DATA
--TWO DIFFERENT WAYS TO INSERT: BY FILLING ALL COLUMNS OR SPECIFYING WHICH COLUMNS TO FILL
INSERT INTO BEAR_TYPE VALUES (1, 'Grizzly');
INSERT INTO BEAR_TYPE (BEAR_TYPE_ID, BEAR_TYPE_NAME) VALUES (2, 'Polar');

INSERT ALL 
INTO CAVE
VALUES(1, 'Tampa', 10)
INTO CAVE(CAVE_ID, CAVE_NAME)
VALUES(37, 'Nashville')
SELECT * FROM DUAL; --DUAL IS A DUMMY TABLE 

INSERT ALL 
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES(72, 'Barry', TO_DATE('1987-08-18 00:00:00','yyyy-mm-dd hh24:mi:ss'),1,37)
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES(891, 'Tim', TO_DATE('1902-08-18 00:00:00','yyyy-mm-dd hh24:mi:ss'),1,1)
INTO BEAR
VALUES(12, 'Walter', TO_DATE('1901-12-05 00:00:00','yyyy-mm-dd hh24:mi:ss'), 800.00,1,1)
INTO BEAR
VALUES(53, 'Brother', TO_DATE('1995-11-11 13:09:00','yyyy-mm-dd hh24:mi:ss'),100,2,37)
SELECT * FROM DUAL;

--WON'T WORK, DUPLICATE PK
--INSERT INTO BEAR VALUES(53, 'Brother', TO_DATE('1995-11-11 13:09:00','yyyy-mm-dd hh24:mi:ss'),100,2,2)
--WON'T WORK, INVALID FOREIGN KEY 
--INSERT INTO BEAR VALUES(54, 'Brother', TO_DATE('1995-11-11 13:09:00','yyyy-mm-dd hh24:mi:ss'),100,3,2);

INSERT ALL 
INTO BEEHIVE 
VALUES (1,30)
INTO BEEHIVE (BEEHIVE_ID)
VALUES (2)
INTO BEAR_BEEHIVE
VALUES (891, 1)
INTO BEAR_BEEHIVE
VALUES (891, 2)
INTO BEAR_BEEHIVE
VALUES (12, 2)
SELECT * FROM DUAL;

--CREATE SEQUENCES: PRODUCE SEQUENTIAL VALUES
CREATE SEQUENCE SQ_BEAR_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_CAVE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEEHIVE_PK
START WITH 1000
INCREMENT BY 1;
/

--TRIGGERS: BLOCK OF CODE THAT WILL EXECUTE IN RESPONSE TO A DML STATEMENT
--(INSERT, UPDATE, DELETE)
--CAN CREATE "BEFORE" OR "AFTER" TRIGGERS 
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/

--TRY IT OUT!
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('Bruce', TO_DATE('1999-04-04','yyyy-mm-dd'), 2, 300);
 
 --GIVE BRUCE SOMEWHERE TO LIVE
 UPDATE BEAR SET CAVE_ID = 1 --SPECIFY TABLE, COLUMN TO BE UPDATED, AND CONDITION
 WHERE BEAR_NAME = 'Bruce';
 
 INSERT INTO CAVE VALUES (52, 'Miami', 4); --ID will get overridden by trigger
 
 --SELECT STATEMENTS
 SELECT * FROM BEAR;
 
 --SELECT ALL GRIZZLY BEARS
 SELECT BEAR_NAME, BIRTHDATE FROM BEAR 
 WHERE BEAR_TYPE_ID = 1
 ORDER BY BEAR_NAME ASC; --ASCENDING IS DEFAULT, OTHERWISE 'DESC' FOR DESCENDING
 
 --SELECT ALL BEARS, ORDERED BY BEAR_TYPE AND BY WEIGHT
 SELECT * FROM BEAR
 ORDER BY BEAR_TYPE_ID, WEIGHT;
 
 --GROUP BY: WILL GIVE ALL DISTINCT VALUES IN THE SPECIFIED COLUMN
 
 --SELECT ALL DISTINCT CAVES TO WHICH BEARS ARE MAPPED
 --ONLY INCLUDE COLUMNS IN RESULT SET RELATED TO WHAT IS BEING GROUPED BY
 SELECT CAVE_ID
 FROM BEAR
 GROUP BY CAVE_ID;

--HOW MANY BEARS PER CAVE?
--'COUNT' IS A SYSTEM-DEFINED AGGREGATE FUNCTION
SELECT CAVE_ID, COUNT(BEAR_ID) AS NUMBEAR
FROM BEAR
GROUP BY CAVE_ID;

--SELECT ALL CAVES WITH <3 BEARS (JUST CAVE #1 FOR NOW)
SELECT CAVE_ID, COUNT(BEAR_ID) AS NUMBEAR
FROM BEAR
GROUP BY CAVE_ID
HAVING COUNT(BEAR_ID) < 3; --ALLOWS US TO PLACE RESTRICTIONS ON AGGREGATIONS OF DATA

--JOINS:
--ALLOW THE COMBINATION OF DATA FROM MULTIPLE TABLES INTO A SINGLE RESULT SET
--LEFT (OUTER) JOIN
SELECT *
FROM BEAR B --ALIAS THE BEAR TABLE
LEFT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;
--FULL (OUTER) JOIN
SELECT *
FROM BEAR B --ALIAS THE BEAR TABLE
FULL JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;
--RIGHT (OUTER) JOIN
SELECT *
FROM BEAR B --ALIAS THE BEAR TABLE
RIGHT JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;
--INNER JOIN
SELECT *
FROM BEAR B --ALIAS THE BEAR TABLE
INNER JOIN CAVE ON B.CAVE_ID = CAVE.CAVE_ID;
--CROSS JOIN
SELECT *
FROM BEAR
CROSS JOIN CAVE;

--ADD A CAVELESS BEAR
INSERT INTO BEAR(BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, WEIGHT)
VALUES('Barnabas', TO_DATE('1999-04-04','yyyy-mm-dd'), 2, 300);

--VIEWS

--HOW MANY BEARS PER CAVE?
CREATE VIEW VW_BEARS_PER_CAVE(CAVE, NUMBEAR)
AS
SELECT CAVE_NAME, COUNT(BEAR_ID) --SYSTEM-DEFINED AGGREGATE FUNCTION (AS OPPOSED A SCALAR FUNCTION)
FROM BEAR, CAVE
WHERE BEAR.CAVE_ID = CAVE.CAVE_ID
GROUP BY CAVE_NAME;

SELECT * FROM VW_BEARS_PER_CAVE;

--USER-DEFINED FUNCTIONS
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER(X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS 
Z NUMBER;
BEGIN
    IF X>Y THEN
    Z := X; --PL/SQL ASSIGNMENT OPERATOR
    ELSE
    Z := Y;
    END IF;
    RETURN Z;
END;

--CALL OUR FUNCTION!
DECLARE
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
    FIRST_NUM := 22;
    SECOND_NUM := 42;
    MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM);
END;

--CURSOR: POINTER TO THE 'ACTIVE SET'
--MOVE THROUGH A RESULT SET AND PROCESS EACH LINE
CREATE OR REPLACE FUNCTION PRINT_ALL_BEARS
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR 
    SELECT BEAR_ID, BEAR_NAME FROM BEAR;
    RETURN S;
END;

--INVOKE THE FUNCTION
DECLARE
S SYS_REFCURSOR;
SOME_ID BEAR.BEAR_ID%TYPE; --DECLARES SOME_ID IS THE SAME DATATYPE AS BEAR.BEAR_ID
SOME_NAME BEAR.BEAR_NAME%TYPE;
BEGIN
    S := PRINT_ALL_BEARS;
    LOOP
    FETCH S INTO SOME_ID, SOME_NAME; --GRAB VALUES IN COLUMNS OF NEXT ROW IN ACTIVE SET
    EXIT WHEN S%NOTFOUND;            --AND ASSIGN THEM TO SOME_ID, SOME_NAME
    DBMS_OUTPUT.PUT_LINE('ID: '||SOME_ID||', NAME: '||SOME_NAME);
    END LOOP;
    CLOSE S;
END;

ALTER TABLE BEEHIVE ADD CONSTRAINT CK_BEEHIVE_WEIGHT
CHECK (LBS_HONEY >= 0);

--NOW, A STORED PROCEDURE TO FEED THE BEARS
CREATE OR REPLACE PROCEDURE SP_FEED_BEAR(B_ID IN NUMBER, H_ID IN NUMBER, HONEY_AMT IN NUMBER, AMT_FED OUT NUMBER)
IS
--VARIABLE DECLARATIONS
BB_EXISTS INTEGER;
BEGIN
    --CHECK THAT BEAR IS MATCHED CORRECTLY TO BEEHIVE
    SELECT COUNT(BB.BEAR_ID) INTO BB_EXISTS
    FROM BEAR_BEEHIVE BB --ALIASING BEAR_BEEHIVE
    WHERE BB.BEAR_ID = B_ID
    AND BB.BEEHIVE_ID = H_ID;
    --IS THE AMOUNT OF HONEY >0 AND LESS THAN HIVE'S WEIGHT?
    IF BB_EXISTS > 0 AND HONEY_AMT > 0 THEN
        --REDUCE HIVE WEIGHT
        UPDATE BEEHIVE SET LBS_HONEY = LBS_HONEY - HONEY_AMT
        WHERE BEEHIVE_ID = H_ID;
        --INCREASE BEAR WEIGHT
        UPDATE BEAR SET WEIGHT = WEIGHT + HONEY_AMT
        WHERE BEAR_ID = B_ID;
        --SET AMOUNT TO RETURN
        AMT_FED := HONEY_AMT;
    ELSE
        AMT_FED := 0;
    END IF;
    COMMIT;
    --EXCEPTION HANDLING!
    EXCEPTION
    --https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/07_errs.htm
    WHEN OTHERS THEN
    AMT_FED := 0;
    ROLLBACK;
END;

DECLARE
AMT_FED NUMBER;
BEGIN
SP_FEED_BEAR(891,2,5,AMT_FED);
DBMS_OUTPUT.PUT_LINE('FED BEAR: '||AMT_FED||' POUNDS OF HONEY');
END;